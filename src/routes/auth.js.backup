// src/routes/auth.js ‚Äî GUARDIANES 2027 ‚Äî VERSI√ìN COMPLETA FUNCIONAL
const express = require('express');
const router = express.Router();
const { query } = require('../db');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

// ============================================
// CONFIGURACI√ìN
// ============================================
const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-2027-guerrero';
const OTP_EXPIRY_MINUTES = 10;

// ============================================
// UTILIDADES
// ============================================
function generatePhoneHash(phone) {
  return crypto.createHash('sha256')
    .update(phone + (process.env.HASH_SALT || 'guardianes-2027'))
    .digest('hex');
}

function generateOTP() {
  // En desarrollo siempre retorna 345678 para facilitar pruebas
  if (process.env.NODE_ENV !== 'production') {
    return '345678';
  }
  return Math.floor(100000 + Math.random() * 900000).toString();
}

// ============================================
// ENDPOINTS
// ============================================

/**
 * POST /api/auth/request-code
 * Solicitar c√≥digo OTP por SMS
 */
router.post('/request-code', async (req, res) => {
  try {
    const { phone } = req.body;

    // Validar formato de tel√©fono (10 d√≠gitos)
    if (!phone || !/^\d{10}$/.test(phone)) {
      return res.status(400).json({ 
        error: 'N√∫mero telef√≥nico inv√°lido. Deben ser 10 d√≠gitos.' 
      });
    }

    const phoneHash = generatePhoneHash(phone);
    const otp = generateOTP();
    const otpExpires = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60000);

    console.log(`üì± OTP solicitado para ${phone}: ${otp}`);

    // UPSERT: insertar usuario nuevo o actualizar OTP si ya existe
    await query(`
      INSERT INTO users (
        phone_hash, 
        phone_last4, 
        otp_code, 
        otp_expires, 
        created_at, 
        is_active
      )
      VALUES ($1, $2, $3, $4, NOW(), true)
      ON CONFLICT (phone_hash) DO UPDATE SET
        otp_code = EXCLUDED.otp_code,
        otp_expires = EXCLUDED.otp_expires,
        updated_at = NOW()
    `, [phoneHash, phone.slice(-4), otp, otpExpires]);

    console.log(`‚úÖ OTP guardado en BD para ${phone.slice(-4)}`);

    // En desarrollo retornar el OTP para facilitar pruebas
    const response = {
      success: true,
      message: 'C√≥digo enviado exitosamente'
    };

    if (process.env.NODE_ENV !== 'production') {
      response.debug_otp = otp;
      console.log(`üîë DEBUG OTP: ${otp}`);
    }

    res.json(response);

  } catch (error) {
    console.error('‚ùå Error en /request-code:', error);
    res.status(500).json({ 
      error: 'Error al generar c√≥digo',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

/**
 * POST /api/auth/verify-code
 * Verificar c√≥digo OTP y retornar JWT
 */
router.post('/verify-code', async (req, res) => {
  try {
    const { phone, code } = req.body;

    if (!phone || !code) {
      return res.status(400).json({ error: 'Tel√©fono y c√≥digo requeridos' });
    }

    const phoneHash = generatePhoneHash(phone);

    console.log(`üîç Verificando c√≥digo para ${phone.slice(-4)}`);

    // Buscar usuario por hash de tel√©fono
    const result = await query(`
      SELECT 
        id, 
        otp_code, 
        otp_expires, 
        is_active,
        phone_last4,
        name,
        points
      FROM users
      WHERE phone_hash = $1
    `, [phoneHash]);

    if (result.rows.length === 0) {
      console.log(`‚ùå Usuario no encontrado para ${phone.slice(-4)}`);
      return res.status(404).json({ 
        error: 'Usuario no encontrado. Solicita un c√≥digo primero.' 
      });
    }

    const user = result.rows[0];

    // Validar cuenta activa
    if (!user.is_active) {
      return res.status(403).json({ error: 'Cuenta inactiva' });
    }

    // Validar c√≥digo
    if (user.otp_code !== code) {
      console.log(`‚ùå C√≥digo incorrecto para ${phone.slice(-4)}`);
      return res.status(401).json({ error: 'C√≥digo incorrecto' });
    }

    // Validar expiraci√≥n
    if (new Date(user.otp_expires) < new Date()) {
      console.log(`‚ùå C√≥digo expirado para ${phone.slice(-4)}`);
      return res.status(401).json({ 
        error: 'C√≥digo expirado. Solicita uno nuevo.' 
      });
    }

    // C√≥digo v√°lido ‚Üí limpiar OTP y generar token
    await query(`
      UPDATE users 
      SET 
        otp_code = NULL, 
        otp_expires = NULL, 
        is_verified = true,
        last_active = NOW(),
        updated_at = NOW()
      WHERE id = $1
    `, [user.id]);

    // Generar JWT
    const token = jwt.sign(
      { 
        userId: user.id,
        phone: phone.slice(-4),
        role: 'user'
      },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    console.log(`‚úÖ Token generado para usuario ${user.id}`);

    res.json({
      success: true,
      token,
      user: {
        id: user.id,
        phone: user.phone_last4,
        name: user.name || `Usuario ${user.phone_last4}`,
        points: user.points || 0
      }
    });

  } catch (error) {
    console.error('‚ùå Error en /verify-code:', error);
    res.status(500).json({ 
      error: 'Error verificando c√≥digo',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

/**
 * GET /api/auth/me
 * Obtener datos del usuario autenticado
 */
router.get('/me', async (req, res) => {
  try {
    // Extraer token del header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token no proporcionado' });
    }

    const token = authHeader.split(' ')[1];

    // Verificar token
    let decoded;
    try {
      decoded = jwt.verify(token, JWT_SECRET);
    } catch (err) {
      console.log('‚ùå Token inv√°lido:', err.message);
      return res.status(401).json({ error: 'Token inv√°lido' });
    }

    if (!decoded.userId) {
      return res.status(401).json({ error: 'Token malformado' });
    }

    // Buscar usuario en BD
    const result = await query(`
      SELECT 
        id, 
        phone_last4, 
        name, 
        points, 
        level, 
        role,
        predictions_count,
        surveys_completed
      FROM users
      WHERE id = $1 AND is_active = true
    `, [decoded.userId]);

    if (result.rows.length === 0) {
      return res.status(401).json({ error: 'Usuario no encontrado' });
    }

    const user = result.rows[0];

    res.json({
      id: user.id,
      phone: user.phone_last4,
      name: user.name || `Usuario ${user.phone_last4}`,
      points: user.points || 0,
      level: user.level || 'Observador',
      role: user.role || 'user',
      predictions: user.predictions_count || 0,
      surveys: user.surveys_completed || 0
    });

  } catch (error) {
    console.error('‚ùå Error en /me:', error);
    res.status(401).json({ error: 'Error de autenticaci√≥n' });
  }
});

/**
 * PUT /api/auth/profile
 * Actualizar perfil del usuario
 */
router.put('/profile', async (req, res) => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token no proporcionado' });
    }

    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, JWT_SECRET);

    if (!decoded.userId) {
      return res.status(401).json({ error: 'Token inv√°lido' });
    }

    const { name, municipality_id } = req.body;

    await query(`
      UPDATE users 
      SET 
        name = COALESCE($1, name),
        municipality_id = COALESCE($2, municipality_id),
        updated_at = NOW()
      WHERE id = $3
    `, [name || null, municipality_id || null, decoded.userId]);

    res.json({ 
      success: true, 
      message: 'Perfil actualizado exitosamente' 
    });

  } catch (error) {
    console.error('‚ùå Error en /profile:', error);
    res.status(500).json({ error: 'Error al actualizar perfil' });
  }
});

module.exports = router;